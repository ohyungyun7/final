2022.04.24.

[ 1과목 : 소프트웨어 설계 (20문항) ]

1. UML 다이어그램 - 순차다이어그램 >>> 행위 다이어그램으로 동적이고, 순차적인 표현을 위한 다이어그램이다.
- 객체 간의 동적 상호작용을 시간 개념을 중심으로 모델링 하는 것이다.
- 일반적으로 다이어그램의 수직 방향이 시간의 흐름을 나타낸다.
- 회귀메시지, 제어블록 등으로 구성된다.

2. 메시지지향미들웨어(MOM)
- 독립적인 애플리케이션을 하나의 통합된 시스템으로 묶기 위한 역할을 한다.
- 송신측과 수신측의 연결 시 메시지큐를 활용하는 방법이 있다.
- 상이한 애플리케이션 간 통신을 비동기방식으로 지원한다.
- 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용한다.
- 즉각적인 응답을 원하는 경우가 아니라 다소 느리고 안정적인 응답을 필요로 하는 경우에 많이 사용된다.

3. 익스트림 프로그래밍
- 애자일 방법론 중 하나이다. ( vs. 구조적 방법론) 
- 소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다.
- 익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어올리는 것이다.
- 구체적인 실천방법을 정의하고 있으며, 개발문서보다는 소스코드에 중점을 둔다.

4. 유스케이스의 구성요소 간의 관계
- 연관관계 : 유스케이스와 액터 간의 상호작용이 있음을 표현한다.
- 포함관계 : 하나의 유스케이스가 다른 유스케이스의 실행을 전제로 할 때 형성되는 관계이다.
- 확장관계 : 확장기능 유스케이스와 확장대상 유스케이스 사이에 형성되는 관계이다.
- 일반화관계 : 유사한 유스케이스 또는 액터를 모아 추상화한 유스케이스 또는 액터와 연결시켜 그룹을 만들어 이해도를 높이기 위한 관계이다.

5. 기능적 요구사항 vs. 비기능적 요구사항
- 기능적 요구사항 : 시스템이 실제로 어떻게 동작하는지에 관점을 둔 요구사항
- 비기능적 요구사항 : 시스템 구축에 대한 성능, 보안, 품질, 안정 등에 대한 성능, 보안, 품질, 안전성 등으로 실제 수행에 보조적인 요구사항
ex) 차량대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야한다는 것은 성능에 해당하므로 비기능적 요구에 해당한다.

6. 정보공학방법론에서 데이터베이스 설계의 표현 >> Entity-Relationship Diagram
- uml다이어그램 >> Package, State Transition, Deployment Diagram

7. 미들웨어
- 클라이언트와 서버 간의 통신을 담당하는 시스템 소프트웨어이다.
- 이기종 하드웨어, 소프트웨어, 네트워크, 프로토콜, PC환경, 운영체제 환경 등에서 시스템 간의 표준화된 연결을 도와주는 소프트웨어이다.
- 운영체제와 애플리케이션 사이에서 중간 매개역할을 하는 다목적 소프트웨어이다.
- 여러 운영체제에서 응용프로그램들 사이에 위치한 소프트웨어이다.
- 소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공한다.
- 여러 컴포넌트를 1대1, 1대다, 다대다 등 여러가지 형태로 연결이 가능하다.
- 미들웨어솔루션은 미들웨어의 서비스 이용을 위해 사용자가 정보교환 방법 등의 내부 동작을 확인할 필요가 없다.

8. UI의 설계지침
- 사용자 중심 : 사용자가 이해하기 쉽고 편하게 사용할 수 있는 환경을 제공해 실사용자에 대한 이해가 바탕이 되어야 한다.
- 일관성 : 버튼이나 조작방법을 사용자가 기억하기 빠르고 쉽게 습득할 수 있도록 설계해야 한다.
- 단순성 : 조작방법은 가장 간단하게 작동되도록 하여 인지적 부담을 최소화한다.
- 결과예측 가능성 : 작동시킬 기능만 보고도 결과예측이 가능해야 한다.
- 접근성 : 사용자의 직무, 연령, 성별 등이 고려된 다양한 계층을 수용해야 한다.
- 오류발생 해결 : 사용자가 오류에 대한 상황을 정확하게 인지할 수 있어야 한다. 

9. 객체지향 개념에서의 다형성(Polymorphism)
- 다형성은 현재코드를 변경하지 않고 새로운 클래스를 쉽게 추가할 수 있게 한다.
- 다형성이란 여러가지 형태를 가지고 있다는 의미로, 여러 형태를 받아들일 수 있는 특징을 말한다.
- 메소드 오버라이딩은 상위클래스에서 정의한 일반메소드의 구현을 하위클래스에서 무시하고 재정의할 수 있다.
  상속관계에서만 발생. 슈퍼클래스의 메서드를 서브클래스에서도 동일한 메서드를 재정의하는 것
- 메소드 오버로딩은 같은 이름의 메소드를 중복하여 정의하는 것이다. 
  한 클래스 내에서 메서드의 이름은 동일하지만 매개변수의 수나 타입을 다르게 하여 재정의 하는 것

10. 인터페이스 	(소프트웨어 개발영역을 결정하는 요소 - 기능, 성능, 제약조건, 인터페이스)
- 서로 다른 두 시스템이나 소프트웨어 등을 서로 이어주는 부분 또는 접속 장치를 의미
- 소프트웨어에 의해 간접적으로 제어되는 장치와 소프트웨어를 실행하는 하드웨어
- 기존의 소프트웨어와 새로운 소프트웨어를 연결하는 소프트웨어
- 순서적 연산에 의해 소프트웨어를 실행하는 절차

11. 객체
- 객체는 상태, 동작, 고유 식별자를 가진 모든 것이라 할 수 있다.
- 클래스는 공통속성을 공유하는 객체들의 집합이다.
- 객체는 필요한 자료구저와 이에 수행되는 함수들을 가진 하나의 독립된 존재이다.
- 객체의 상태는 속성값에 의해 정의된다.

12. 캡슐화 : 석성과 관련된 연산을 클래스 안에서 묶어서 하나로 취급하는 것을 의미. 서로 관련성이 많은 데이터들과 연산들을 묶는다.
- 클래스 : 하나 이상의 유사한 객체들을 묶는다.
(inheritance, association)

13. 애자일 개발 프로세스
- 개발에 대한 개념적 방법론으로, 개발 프로젝트 기간을 짧은 주기로 나눠 반복적인 개발을 하는 것이 특징
- 고객관점의 효율적이고 민첩한 변화 대응을 중시
- 문서중심이 아닌 실행 가능한 소프트웨어를 중시. 협상과 계약보다는 고객과의 협력을 중시한다.
- 프로세스와 도구 중심이 아닌 개개인과의 상호소통을 통해 의견을 수렴한다.

14. 컴포넌트(component)  (model, sheet, cell)
- 명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서 재샤용되는 모든 단위. 인터페이스를 통해서만 접근 가능
- 프로그래밍에 있어 재사용이 가능한 각각의 독립된 모듈. 특정 기능 수행을 위해 독립적으로 분리.




15. GoF디자인 패턴
- 생성패턴 : 객체를 생성하는 것에 대한 패턴
	추상팩토리, 빌더, 팩토리메소드, 프로토타입, 싱글톤
- 구조패턴 : 구조를 통해 확장성을 꾀하는 패턴
	어댑터, 브릿지, 컴포지트, 데코레이터, 퍼사드, 프라이웨잇, 프록시
- 행위패턴 : 행위의 변경, 수정 등을 위한 패턴
	역할사슬, 커맨드, 인터프리터, 이터레이터, 미디에이터, 메멘토, 옵저버, 상태, 전략, 템플릿메소드, 비지터 

16. 피드백 (posture, module, hash)
- 처리된 결과를 측정하고 목표에 도달되었는가를 검사하며 불충분할 경우 다시 입력하는 요소

17. 사용자인터페이스 UI
- CLI(Command Line Interface) : 텍스트 형태 인터페이스
- GUI(Graphical User Interface) : 마우스로 선택하여 작업하는 그래픽 환경 인터페이스
- NUI(Natural User Interface) : 사용자의 말이나 행동으로 기기 조작하는 인터페이스
- VUI(Voice User Interface) : 사람의 음성으로 기기를 조작하는 인터페이스
- OUI(Organic User Interface) : 모든 사물과 사용자 간의 상호작용을 위한 인터페이스

18. 소프트웨어 모델링
- 구조록적 방법론에서는 DFD, DD 등을 사용하여 요구사항의 결과를 표현한다.
- 객체지향 방법론에서는 UML표기법을 사용한다.
- 소프트웨어 모델을 사용할 경우 개발될 소프트웨어에 대한 이해도 및 이해당사자 간의 의사소통 향상에 도움이 된다.
- 모델링 작업의 결과물은 다른 모델링 작업에 영향을 줄 수 있다.

19. 유스케이스다이어그램
- 유스케이스는 사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술한다.
- 시스템 액터는 다른 프로젝트에서 이미 개발되어 사용되고 있으며, 본 시스템과 데이터를 주고받는 등 서로 연동되는 시스템을 말한다.
- 액터가 인식할 수 없는 시스템 내부의 기능을 하나의 유스케이스로 파악해서는 안 된다.
- 액터 : 시스템과 상호작용하는 모든 것. 사람이나 기계, 외부시스템을 의미한다.

20. MVC
- MVC모델은 사용자 인터페이스를 담당하는 계층의 응집도를 높일 수 있고, 여러 개의 다른 UI를 만들어 그 사이에 결합도를 낮출 수 있다.
- 뷰는 모델에 있는 데이터를 사용자 인터페이스에 보이는 역할을 담당한다.
- 컨트롤러는 모델에 명령을 보냄으로써 모델의 상태를 변경할 수 있다.
- 한 개의 모델에 대해 여러 개의 뷰를 만들 수 있다.
- 모델은 서브 시스템의 핵심기능과 데이터를 보관하며 MVC패턴에서는 여러 개의 뷰를 만들 수 있으므로 한 개의 모델에 대해 여러개의 뷰를 필요로 하는 대화형 어플리케이션에 적합하다.










[2과목 : 소프트웨어 개발]

21. 통합테스트
- 시스템을 구성하는 모듈의 인터페이스와 결합을 테스트하는 것이다.
- 하향식 통합테스트의 경우 넓이우선방식으로 테스트를 할 모듈을 선택할 수 있다.
- 모듈 간의 인터페이스와 시스템의 동작이 정상적으로 잘 되고 있는지를 빨리 파악하고자 할 때 상향식보다는 하향식 통합 테스트를 사용하는 것이 좋다.
- 상향식통합테스트 : 프로그램의 하위모델에서 상위 모듈 방향으로 통합. 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터 필요
- 하향식통합테스트 : 상위 모듈에서 하위모듈 방향으로 통합. 깊이우선, 넓이우선 통합법 사용. 초기부터 사용자에게 시스템 구조를 보여줌

22. 이진 탐색 동작 방식
- 배열의 중간값 찾음 > 중간값과 검색값을 비교 > 중간값이 검색값과 같으면 끝, 중간값보다 검색값이 크다면 오른쪽구간을 탐색, 중간값보다 검색값이 작다면 왼쪽구간을 탐색
ex) 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 : 찾을 값 14
중간값 : (0+14)/2 = 7
7 < 14  // 8 (1번)
(8+14)/2 = 11
11 < 14 // 12 (2번)
(12+14)/2 = 13 
13 < 14 // 14 (3번)

23. 워크스루(walkthrough) : 요구사항명세서 작성자를 포함하여 사전 검토한 후에 짧은 검토회의를 통해 결함을 발견
- 사용사례를 확장하여 명세하거나 설계다이어그램, 원시코드, 테스트케이스 등에 적용할 수 있다.
- 복잡한 알고리즘 또는 반복, 실시작 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용하다.
- 단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해 보는 것이다.
- 인스펙션 : 요구사항명세서 작성자를 제외한 다른 검토전문가들이 요구사항 명세서를 확인하면서 결함을 발견

24. 소프트웨어의 개발과정
- 형상관리 : 소프트웨어 개발과정에서 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동
- 복호화 : 디코딩, 즉 부호화된 데이터를 부호화 되기 전 형태로 바꾸어 사람이 읽을 수 있는 형태로 되돌려 놓는 것
- 크랙 : 소프트웨어를 수정하여 소프트웨어를 크랙하는 사람이 원하지 않는 기능들, 보통은 수정방식(복사보호, 소프트웨어 조작보호)을 비활성하거나 제거하는 일

25. 테스트케이스
- 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력값, 실행조건, 기대결과 등으로 구성된 테스트 항목에 대한 명세서를 의미
- 테스트의 목표 및 테스트 방법을 결정하고 테스트케이스를 작성해야 한다. 
- 프로그램에 결함이 있더라도 입력에 대해 정상적인 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트케이스를 찾는 것이 중요하다.
- 개발된 서비스가 정의된 요구사항을 준수하는지 확인하기 위한 입력값과 실행조건, 예상결과의 집합으로 볼 수 있다.
-  테스트케이스의 실행이 통과되었는지 실패하였는지 판단하기 위한 기준을 테스트오라클이라고 한다.

26. 객체지향
- 객체란 필요한 자료구조와 수행되는 함수들을 가진 하나의 독립된 존재이다.
- 상속은 개별클래스를 상속관계로 묶음으로써 클래스 간의 체계화된 전체 구조를 파악하기 쉽다는 장점이 있다.
- 같은 클래스에 속하는 개개의 객체이자 하나의 클래스에서 생성된 객체를 인스턴스라고 한다.
- 자바에서 정보은닉을 표기할 때 private는 외부에서 클래스 내부 정보에 접근하기 못하도록 하는 접근금지이다.

27. DRM(Digigal Right Management)
- 디지털 콘텐츠와 디바이스의 사용을 제한하기 위해 하드웨어 제조업자, 저작권자, 출판업자 등이 사용할 수 있는 접근제어기술을 의미
- 디지털미디어의 생명주기 동안 발생하는 사용권한관리, 과금, 유통단계를 관리하는 기술로도 볼 수 있다.
- 클리어링하우스는 사용자에게 콘텐츠라이센스를 발급하고 권한을 부여해주는 시스템을 말한다.
- 디지털콘텐츠의 지적재산권보호, 관리기능 및 안전한 유통과 배포를 보장하는 솔루션이다.
- 권한통제기술, 사용권한제어 기술, 패키징기술, 라이선스 관리를 포함한 유통체계이다.

28. 위험모니터링
- 위험요소 징후들에 대하여 계속적으로 인지하는 것

29. RCS(Revision Control System)
- 소스파일의 수정을 한 사람만으로 제한.
- 다수의 사용자가 동시에 파일 수정을 할 수 없도록 파일 잠금 방식으로 버전을 관리하는 도구
- 다른 방향으로 진행된 개발결과를 합치거나 변경내용을 추적할 수 있다.

RPC(Remote Procedure Cell)
- 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 리모트의 함수나 프로시저를 실행할 수 있게 해주는 프로세스 간 통신

RTS(Reliable Transfer Service), RVS(Relative Version System)

30. 화이트박스 테스트
- 화이트박스 테스트의 이해를 위해 논리흐름도를 이용할 수 있다.
- 테스트데이터를 이용해 실제 프로그램을 실행함으로써 오류를 찾는 동적테스트에 해당한다.
- 테스트 데이터를 선택하기 위하여 검증기준을 정한다.

- 프로그램 구조를 고려하지 않는 것은 블랙박스 테스트

31. 알고리즘
- 주어진 작업을 수행하는 컴퓨터명령어를 순서대로 나열한 것.
- 검색은 정렬이 되지 않은 데이터 혹은 정렬이 된 데이터 중에서 키값에 해당되는 데이터를 찾는 알고리즘이다.
- 정렬은 흩어져 있는 데이터를 키값을 이용하여 순서대로 열거하는 알고리즘이다.
- 선형검색은 처음부터 끝까지 하나씩 순서대로 비교하며 원하는 값을 찾아내는 검색이다.
- 이진검색은 검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 한다.

32. 버블정렬
- 버블정렬은 첫위치부터 시작해서 오른쪽값과 비교
ex) 9,6,7,3,5
6,9,7,3,5 > 6,7,9,3,5 > 6,7,3,9,5 > 6,7,3,5,9 (pass1의 결과값)

33. 인스펙션의 과정
- 계획 > 사전교육 > 준비 > 인스펙션회의 > 수정 > 후속조치





34.
- Refactoring :  코드의 구조 재조정. 소프트웨어를 보다 쉽게 이해할 수 있고 적은 비용으로 수정할 수 있도록 겉으로 보이는 동작의 변화없이 내부구조를 변경하는 것
- Architecting : 설계관련
- Spectification : 명세서
- Renewal : 유지보수 (유지보수와 리팩토링은 다른 개념이다.)

35. 단위테스트
- 구현단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트한다.
- 모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행한다.
- 테스트할 모듈을 호출하는 모듈도 있고, 테스트할 모듈이 호출하는 모듈도 있따.
- 상위모듈의 역할을 하는 가상의 모듈을 테스트드라이버라고 하고, 그 역할은 테스트할 모듈을 호출하는 것이다. 
	즉, 필요한 데이터 인자를 통하여 넘겨주고, 테스트가 완료된 후 그 결과값을 받는 역할을 해준다.
- 통합테스트 : 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 스텁이라 한다.

36. IED 도구
- coding : 프로그래밍 언어를 가지고 컴퓨터 프로그램을 작성할 수 있는 환경을 제공
- compile : 주어진 언어로 작성된 컴퓨터 프로그램을 다른 언어의 동등한 프로그램으로 변환하는 기능. 
- 		고급언어(사람이 인식하는 언어)에서 저급언어(기계어)로 바꾸는 기능
- debugging : 프로그램에서 발견되는 버그를 찾아 수정할 수 있는 기능
- deployment : 소프트웨어를 최종 사용자에게 전달하기 위한 기능

37. 트리구조
- 전위 운행 : 뿌리(상단), 왼쪽, 오른쪽 순서
- 중위 운행 : 왼쪽, 뿌리, 오른쪽 순서
- 후위 운행 : 왼쪽, 오른쪽, 뿌리 순서

38. JSON
- 속성-값 쌍으로 이루어진 데이터 오브젝트를 전달하기 위해 사용하는 개방형 표준 포맷
- AJAX에서 많이 사용되고 XML을 대체하는 주요 데이터 포맷
- 언어 독립형 데이터 포맷으로 다양한 프로그래밍 언어에서 사용되고 있다.

39. Stack : LIFO 한쪽 끝에서 일어남. 순서가 있는 리스트에서 데이터의 삽입, 삭제가 한쪽 끝에서 일어난다.
- Queue L FIFO 양방향에서 일어남
- Tree & Graph 비선형구조

40. 단위 테스트 도구
- CppUnit : C++ 프로그래밍 언어용 단위 테스트 도구
- JUnit : 자바 프로그래밍 언어용 단위 테스트 도구
- HttpUnit : 웹브라우저 없이 웹사이트 테스트를 수행하는 데 사용되는 오픈 소스 소프트웨어 테스트 프레임워크
- IgpUnit








[ 3과목 : 데이터베이스 구축 ]

41. 정규화 과정
- 1NF : 모든 도메인이 원자값으로만 구성
- 2NF : 기본키가 아닌 속성이 기본키에 대한 완전 함수적 종속을 만족, 부분적 함수 종속을 제거한 정규형
- 3NF : 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수 종속 관계를 만족하지 않는 정규형
- BCNF : 모든 ‘결정자’가 후보키인 정규형, 종속성 보존 안됨
- 4NF : 다치 종속이 성립하는 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족
- 5NF : 모든 조인 종속이 R의 후보키를 통해서만 성립되는 정규형
42. 트랜잭션 (A.C.I.D)
- 원자성(Atomicity) : 완전하게 수행 완료되지 않으면 전혀 수행되지 않아야 함
- 일관성(Consistency) : 시스템의 고정요소는 트랜잭션 수행 전후에 같아야 함
- 격리성(Isolation) : 고립성. 트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않아야 함
- 영속성(Durability) : 지속성. 트랜잭션의 완료 결과가 데이터베이스에 영구히 기억되야 함

43. 분산 데이터베이스
- 위치 투명성 : 하드웨어와 소프트웨어의 물리적 위치를 사용자가 알 필요 없다.
- 중복(복제) 투명성 : 사용자에게 통지할 필요없이 시스템 안에 파일들과 저원들의 부가적인 복사를 자유롭게 할 수 있다.
- 병행 투명성 : 다중 사용자들이 자원들을 자동으로 공유할 수 있다.
- 장애 투명성 : 사용자들은 어느 위치의 시스템에 장애가 발생했는지 알 필요가 없다.

44. 내가 풀 수 있는 sql문

45. 데이터베이스의 인덱스
- 데이터베이스 성능에 많은 영향을 주는 DBMS의 구성요소로 테이블과 클러스터에 연관되어 독립적인 저장공간을 보유하며, 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 별도로 구성한 순서 데이터를 말한다.
- 대부분의 데이터베이스에서 테이블을 삭제하면 인덱스도 같이 삭제된다.
- 인덱스 생성 : create / 인덱스 삭제 : drop

46. 물리적 데이터베이스 구조의 기본데이터 단위인 저장레코드 양식 설계
- 데이터 타입, 데이터값의 분포, 접근빈도
- 트랜잭션을 개념적 시스템 독립적으로 정의한다.  
- 트랜잭션의 입출력 기능, 형태만 정의한다. 검색-갱신 혼합
- 트랜잭션 모델링은 개념적 설계 단계에서 하는 것

47. SQL 
- DCL(Data Control Language) : commit, rollback, grant, revoke(사용자로부터 사용권한 취소)
- DDL(Data Definition Language) : create, alter, drop
- DML(Data Manipulation Language) : select, insert, delete, update 
- DUL(Data User Language)

48. 데이터사전
- 시스템 자신이 필요로 하는 여러 가지 객체(기본테이블, 뷰, 인덱스, 데이터베이스, 패키지, 접근권한 등)에 관한 정보를 포함하고 있는 시스템 데이터베이스.
- 시스템 카탈로그, 메타데이터라고도 한다.
- 시스템 카탈로그 자체도 시스템 테이블로 구성되어 있어 SQL문을 이용하여 내용 검색이 가능하다.
- 사용자가 시스템 카탈로그를 직접 갱신할 수 없다.
- SQL문으로 여러 가지 객체에 변화를 주면 시스템이 자동으로 갱신한다.

49. 데이터베이스에서의 릴레이션
- 튜플의 순서는 정해져 있지 않다.
- 모든 튜플은 서로 다른 값을 가지고 있다.
- 각 속성은 릴레이션 내에서 유일한 이름을 가진다.
- 모든 속성 값은 원자값을 가진다.

50. 데이터베이스에서의 뷰(view)
- 뷰는 다른 뷰를 기반으로 새로운 뷰를 만들 수 있다.
- 뷰는 일종의 가상 테이블이며, update에는 제약이 따른다.
- 뷰는 기본 테이블을 만드는 것처럼 create view를 사용하여 만들 수 있다.
- 뷰는 논리적으로만 존재한다. 
- 
51. Partially Committed
- 트랜잭션의 상태 중 트랜잭션의 마지막 연산이 실행된 직후의 상태로, 모든 연산의 처리는 끝났지만 트랜잭션이 수행한 최종결과를 데이터베이스에 반영하지 않은 상태.

52. 키의 종류 (atomic key, test key)
- super key : 속성들의 집합으로 구성된 키. 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다.
- candidate key : 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합.

53. 데이터베이스
- 개념설계(트랜잭션 모델링) >>> 논리설계(트랜잭션 인터페이스 설계) >>> 물리설계(트랜잭션 세부설계) [개논물]
- 개념적 설계 : 트랜잭션 모델링. 독립적인 개념 스키마 모델링. 개념스키마 설계. E-R 다이어그램
- 논리적 설계 : 트랜잭션 인터페이스 설계. DBMS에 맞는 논리스키마 설계. 테이블 설계. 논리적 매핑. 스키마 평가 및 정제
- 물리적 설계 : 레코드 집중의 분석, 설계. 저장 레코드 양식 설계. 저장주고 및 액세스 경로 설정.

54. 기본키
- 후보키 중에서 선정된 주키로 중복된 값을 가질 수 없다.
- 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성
- 기본키는 후보키의 성질을 갖는다. 즉 튜플을 식별하기 위해 반드시 필요한 키.
- 기본키는 null을 가질 수 없다. 즉 기본키로 설정된 속성에는 null값이 있어서는 안 된다.

55. 데이터모델의 구성요소
- 구조(Structure) : 논리적인 개체 타입들 간의 관계, 데이터 구조 및 정적 성질을 표현
- 연산(Operation) : 실제 데이터를 처리하는 작업에 대한 명세로, 조작하는 기본 도구
- 제약조건(Constraint) : DB에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

56. sql문









57. 기본키
- 테이블의 각 레코드를 고유하게 식별하는 필드나 필드의 집합이다.
- 테이블에 기본키 설정은 필수가 아니다.
- 기본키를 설정하지 않고도 다른 테이블과의 관계를 설정할 수 있다.
- 기본키는 혼합속성(다수 필드)에 설정할 수 있다.
- 개체 무결성 : 각 릴레이션의 기본키를 구성하는 속성은 널값이나 중복된 값을 가질 수 없다.
- 참조 무결성 : 외래키값은 널이거나 참조하는 릴레이션의 기본키값과 동일해야 한다.
- 도메인 무결성 : 속성들의 값은 정의된 도메인에 속한 값이어야 한다.
- 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 릴레이션의 각 튜플이 가지는 속성 값들은 서로 달라야 한다.
- NULL 무결성 : 릴레이션의 특정 속성 값은 NULL이 될 수 없다.
- 키 무결성 : 각 릴레이션은 최소한 한 개 이상의 키가 존재해야 한다.
- 
58. Cardinality : 기수. 튜플의 수
- Degree : 차수. 속성의 수

60. SQL문
- create table : 테이블을 생성할 수 있는 권한 부여
- revoke create table from : 테이블을 생성할 수 있는 권한 취소






























[ 4과목 : 프로그래밍언어 활용 ]

61. C언어
- strlen(s) : s의 길이를 구한다.
- strcpy(s1, s2) : s2를 s1으로 복사한다.
- strcmp(s1, s2) : s1과 s2의 문자열을 비교한다.
- strrev(s) : s를 거꾸로 변환한다.
- strcat : 문자열을 연결한다.

62. C언어 연산

63. C언어 연산

64. IP 프로토콜
- Header Length는 IP 프로토콜의 헤더 길이를 32비트 워드 단위로 표시한다.
- Total Packet Length(16bits) : IP헤더 및 데이터를 포함한 IP패킷 전체 길이를 바이트 단위로 길이를 표시 (최댓값은 65,535 = 2^16-1)
- Time To Live는 송신 호스트가 패킷을 전송하기 전 네트워크에서 생존할 수 있는 시간을 지정한 것이다.
- Version Number는 IP 프로토콜의 버전번호를 나타낸다.

65. 내가 아는 Python 문제

66. RIP(Routiong Information Protocol)
- 최단 경로 탐색에는 Bellman-Ford 알고리즘을 사용하는 거리 벡터 라우팅 프로토콜
- 라우팅 프로토콜을 IGP와 EGP로 분류했을 때 IGP에 해당한다.
- 최단경로탐색에는 Bellman-Ford 알고리즘을 사용한다.
- 최적의 경로를 산출하기 위한 정보로서 홉(거리 값)만을 고려하므로, RIP을 선택한 경로가 최적의 경로가 아닌 경우가 많이 발생할 수 있따.
- 소규모 네트워크 환경에 적합하다.
- 최대 홉 카운트를 15홉 이하로 한정하고 있다.

67. HRN 스케줄링 방식
- 비선점 스케줄링 : 실행시간이 긴 프로세스에 불리한 SJF를 보완하기 위해 대기시간 및 서비스 시간을 이용
- 긴 작업과 짧은 작업 간의 지나친 불평등을 해소할 수 있다.
- 우선순위를 계산 숫자가 높은 것부터 낮은순으로 순위를 부여한다.
- (대기시간 + 서비스시간) / 서비스시간 = 우선순위값 >>> 값이 클수록 우선순위가 높다.

68. UNIX 운영체제
- 주로 서버용 컴퓨터에서 사용된다.
- tiem sharing system을 위해 설계된 대화식 운영체제
- C언어로 작성되어 이식성이 높고 장치간 호환성이 높다.
- multi user, multi tasking 모두 지원한다. 트리구조의 파일시스템
- 하나 이상의 작업에 대하여 백그라운드에서 수행이 가능하다.

69. UDP(User Datagram Protocol) 프로토콜
- 비연결형 및 비신뢰성 전송 서비스를 제공한다.
- 흐름 제어나 순서 제어가 없어 전송 속도가 빠르다.
- 수신된 데이터의 순서 재조정 기능을 지원하지 않는다. 단순한 헤더 구조로 오버헤드가 적다.
- 복구 기능을 제공하지 않는다.  TCP와 같이 트랜스포트 계층에 존재한다.
70. Python 데이터 타입
- 시퀀스 – 리스트 : 순서 o, 가변성
- 시퀀스 - 튜플 : 순서 o, 불변성
- 세트 – 세트 : 순서 x, 중복 x
- 맵 – 딕셔너리 : 순서 x, key-value쌍
